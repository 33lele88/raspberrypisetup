#!/bin/bash
# Advanced script to install and configure Arch with ppp on indicated sdcardforarch
# More info and newest @ http://www.github.com/iugamarian/raspberrypisetup
# Version 1.40 tested and it works
# Forked from ShorTie	<idiot@dot.com> 
# Brought to you by iugamarian	<iugamarian@yahoo.com> 
# Configuration - choose here carefuly 

sdcardforarch=/dev/sdx 			# Before running, lsblk to indicate card here
pppusername="userppp"
ppppassword="passwdppp"
pppprovider="isp"
rpiversionnumber=0			# version, not revision:  0 = autodetect, 1 = BCM2835, 2 = BCM2836

# Use a minimum 8 GB card as I also make a swap partition of 512 MB. Down in "Fdisk area".

#********** END Configuration **************************************************************

# Check to see if running as root
echo -e "\nChecking for root."
if [ `id -u` != 0 ]; then
    echo "Not root."
    echo -e "Need to be run as root.\n"
    echo " Try 'sudo sh rpiarchppp' as a user. Exiting."
    echo ""
    exit 1
else
    echo "Root."
fi
# Noting time when started
start_time=$(date)
echo ""
echo ""
# Pi check
if [ `cat /proc/cpuinfo | grep BCM |wc -c` -eq 0 ]; then
    echo "Not running on a Raspberry Pi."
    rpirunningon=0
#   exit 1
else
    echo "Running on a Raspberry Pi."
    rpirunningon=1
fi
echo ""
rpiversioncorrect=0
#Selecting version
if [ $rpiversionnumber -eq 0 ]; then
    # Autodetect
    rpiversioncorrect=1
    echo "Autodetecting Raspberry Pi version..."
    if [ $rpirunningon -eq 1 ]; then
        # Running on a Pi or Pi 2 during autodetect
        echo "The the cpu of this Raspberry Pi is:"
        echo ""
        if [ `cat /proc/cpuinfo | grep ARMv6 |wc -c` -eq 0 ]; then
            echo "BCM2836 ARMv7 Raspberry Pi 2"
            rpiversion="armv7h"
        else
            rpiversion="unknown"
        fi
        if [ `cat /proc/cpuinfo | grep ARMv7 |wc -c` -eq 0 ]; then
            echo "BCM2835 ARMv6 Raspberry Pi"
            rpiversion="armv6h"
        else
            version="unknown"
        fi
        if [ "$rpiversion" = "unknown" ]; then
                echo "Can't autodetect Raspberry Pi version while running on one."
                echo "Choose rpiversionnumber=1 or rpiversionnumber=2 in configuration."
                echo "Exiting."
                echo ""
                exit 1
        fi
    else
        # Not running on Pi or Pi 2 during autodetect
        echo ""
        echo "Can't autodetect Raspberry Pi version when not running on one."
        echo "Choose rpiversionnumber=1 or rpiversionnumber=2 in configuration."
        echo "Exiting."
        echo ""
        exit 1
    fi
    # End of autodetect
else
    echo "Not autodetecting Raspberry Pi version."
    # End of no autodetect message
fi
if [ $rpiversionnumber -eq 1 ]; then
    rpiversion="armv6h"
    rpiversioncorrect=1
fi
if [ $rpiversionnumber -eq 2 ]; then
    rpiversion="armv7h"
    rpiversioncorrect=1
fi
if [ $rpiversioncorrect -eq 0 ]; then
    # Incorrect rpiversionnumber
    echo "Chosen rpiversionnumber is not 0 1 or 2."
    echo "Choose rpiversionnumber=1 or rpiversionnumber=2 in configuration."
    echo "Exiting."
    echo ""
    exit 1
fi
# End of selecting version
echo ""
echo "Selected Arch architecture is:"
echo ""
echo ""
echo $rpiversion
echo ""
echo ""
echo "============================================================"
echo ""
sleep 2
# Allowing dd to be able to clear MBR (permission)
viewsudouser=`logname`
viewroot=""
# A string echo "" is seen by wc as having 1 character so n+1, and a failed grep has a wc of 0
if [ `echo $viewsudouser | grep "root" |wc -c` != 0 ] && [ `echo $viewsudouser |wc -c` = 5 ]; then
viewroot="root"
fi
# On Arch a no login name gives a wc of 1
if [ `echo $viewsudouser |wc -c` = 1 ]; then
viewroot="root"
fi
# On other systems no login name maybe gives no login name
if [ `echo $viewsudouser | grep "no login name" |wc -c` != 0 ]; then
viewroot="root"
fi
if [ `echo $viewroot |wc -c` != 1 ]; then
echo ""
echo "Only root."
echo "Adding root to the disk group."
echo""
usermod -G disk --append root
else
echo ""
echo "Sudo is used by a user named $viewsudouser."
echo "Adding user named $viewsudouser to the disk group."
echo ""
usermod -G disk --append $viewsudouser
fi
echo ""
echo "Checking for programs that are needed:"
echo ""
# If on Arch this commands install them
pacman -Syu --noconfirm
sleep 2
pacman -S --noconfirm --needed base-devel dosfstools wget libarchive
sleep 2
sync
# On other distributions the user installs them
neededprograms=""
if [ `which fdisk |wc -c` != 0 ]; then
echo "Found fdisk."
else
neededprograms+="fdisk "
fi
if [ `which mkfs.vfat |wc -c` != 0 ]; then
echo "Found mkfs.vfat."
else
neededprograms+="mkfs.vfat "
fi
if [ `which wget |wc -c` != 0 ]; then
echo "Found wget."
else
neededprograms+="wget "
fi
if [ `which bsdtar |wc -c` != 0 ]; then
echo "Found bsdtar."
else
neededprograms+="bsdtar "
fi
if [ "$neededprograms" = "" ]; then
echo "All needed programs available."
else
echo "Missing needed programs, install them:"
echo ""
echo $neededprograms
echo ""
echo "On Arch fdisk is in util-linux which is in base-devel."
echo ""
echo "On Arch mkfs.vfat is in dosfstools and bsdtar is in libarchive."
echo ""
echo "Exiting."
echo ""
exit 1
fi
echo ""
# Detecting availability of indicated device
if ! (fdisk -l | grep $sdcardforarch); then
    echo "Can't find ($sdcardforarch). Insert and indicate it."
    echo "No files. Only devices. Exiting."
    echo ""
    exit 1
else
    echo "Found device $sdcardforarch."
    echo ""
fi
echo ""
echo "============================================================"
echo ""
sleep 2
# Safety unmounting of possible partitions, logicals can start from 5
echo "Unmounting partitions, up to 9, with or without p in front:"
echo ""
umount "$sdcardforarch"1
umount "$sdcardforarch"2
umount "$sdcardforarch"3
umount "$sdcardforarch"4
umount "$sdcardforarch"5
umount "$sdcardforarch"6
umount "$sdcardforarch"7
umount "$sdcardforarch"8
umount "$sdcardforarch"9
umount "$sdcardforarch"p1
umount "$sdcardforarch"p2
umount "$sdcardforarch"p3
umount "$sdcardforarch"p4
umount "$sdcardforarch"p5
umount "$sdcardforarch"p6
umount "$sdcardforarch"p7
umount "$sdcardforarch"p8
umount "$sdcardforarch"p9
swapoff "$sdcardforarch"1
swapoff "$sdcardforarch"2
swapoff "$sdcardforarch"3
swapoff "$sdcardforarch"4
swapoff "$sdcardforarch"5
swapoff "$sdcardforarch"6
swapoff "$sdcardforarch"7
swapoff "$sdcardforarch"8
swapoff "$sdcardforarch"9
swapoff "$sdcardforarch"p1
swapoff "$sdcardforarch"p2
swapoff "$sdcardforarch"p3
swapoff "$sdcardforarch"p4
swapoff "$sdcardforarch"p5
swapoff "$sdcardforarch"p6
swapoff "$sdcardforarch"p7
swapoff "$sdcardforarch"p8
swapoff "$sdcardforarch"p9
echo ""
echo "Wait..."
sleep 5
echo ""
echo "Deleting MBR and fat allocation table general area with dd:"
# Need to dd more because fat filesystems may get confused about random
# data in their first part where they store the fat allocation table
dd if=/dev/zero of=$sdcardforarch bs=1M count=32 iflag=fullblock
echo ""
echo ""
echo "Partitioning indicated device:"
echo ""
# On fdisk older than 25, setting bootable flag adds 1 after a: "a,1" < 25, "a" >= 25
# But I follow the archlinuxarm instructions which don't set booteble flag
# "Fdisk area". Be careful about the new lines (Enter).
fdisk $sdcardforarch <<EOF
o
n



+140M
t
c
n



+512M
n




w
EOF
# Finished partitioning. Be careful about the new lines (Enter).
sleep 5
echo ""
echo "=================================================="
echo ""
echo ""
echo "Detecting if the device is seen as a mmcblk so that partitions have a p in front"
echo ""
if [ `echo $sdcardforarch | grep mmcblk |wc -c` != 0 ]; then
echo ""
echo "Partition numbers have a p in front of them..."
bootpart="$sdcardforarch"p1
swappart="$sdcardforarch"p2
rootpart="$sdcardforarch"p3
else
echo ""
echo "Partition numbers don't have a p in front of them..."
bootpart="$sdcardforarch"1
swappart="$sdcardforarch"2
rootpart="$sdcardforarch"3
fi
echo ""
echo -n "Boot partition is "
echo $bootpart
echo -n "Swap partition is "
echo $swappart
echo -n "Root partition is "
echo $rootpart
echo ""
echo ""
echo "Formatting partitions:"
echo ""
mkfs.vfat -n BOOTRPI $bootpart
mkswap $swappart
# Disabling lazy options so that all inodes get written now not bit by bit later.
mke2fs -t ext4 -m 0 -F -L ARCHRPI -E lazy_itable_init=0,lazy_journal_init=0 $rootpart
echo ""
echo "Mounting partitions:"
echo ""
mkdir sdcardforarch
mount $rootpart sdcardforarch
mkdir sdcardforarch/boot
mount $bootpart sdcardforarch/boot
echo ""
echo "=================================================="
echo ""
sleep 2
echo "Downloading Arch image with wget:"
echo ""
echo ""
if [ "$rpiversion" = "armv6h" ]; then
# The nl mirror is faster
wget -c http://nl.mirror.archlinuxarm.org/os/ArchLinuxARM-rpi-latest.tar.gz
echo "Unpacking Arch image with bsdtar... wait... (armv6h)"
bsdtar -xpf ArchLinuxARM-rpi-latest.tar.gz -C sdcardforarch
fi
if [ "$rpiversion" = "armv7h" ]; then
# The nl mirror is faster
wget -c http://nl.mirror.archlinuxarm.org/os/ArchLinuxARM-rpi-2-latest.tar.gz
echo "Unpacking Arch image with bsdtar... wait... (armv7h)"
bsdtar -xpf ArchLinuxARM-rpi-2-latest.tar.gz -C sdcardforarch
fi
sync
echo ""
echo "Detecting exact names for ppp package and it's dependencies:"
echo ""
# The version of a package changes the link when updated to a mirror
# To have the links we need to know their current version
# If you don't have ppp you can't connect to internet if you don't have router and it's pppoe
# Belive me, no internet is a disaster, pacman needs it's mirrors. This is the solution.
# No pacstrap - raspbian would need too many configuration changes and would be crippled (if errors).
# "ppp" depends on "libpcap" which depends on "libnl" which then has all it needs from root.
# So the install order needs to be: libnl -> libpcap -> ppp
# Offline install is done later one by one by script with pacman -U package
coredblink=http://nl.mirror.archlinuxarm.org/"$rpiversion"/core/core.db.tar.gz
wget $coredblink
mkdir archcoredbextract
bsdtar -xpf core.db.tar.gz -C archcoredbextract
namelibnl=`ls archcoredbextract | grep libnl`
namelibpcap=`ls archcoredbextract | grep libpcap`
nameppp=`ls archcoredbextract | grep ppp`
echo $namelibnl
echo $namelibpcap
echo $nameppp
#And the links are:
linklibnl=http://nl.mirror.archlinuxarm.org/"$rpiversion"/core/"$namelibnl"-"$rpiversion".pkg.tar.xz
linklibpcap=http://nl.mirror.archlinuxarm.org/"$rpiversion"/core/"$namelibpcap"-"$rpiversion".pkg.tar.xz
linkppp=http://nl.mirror.archlinuxarm.org/"$rpiversion"/core/"$nameppp"-"$rpiversion".pkg.tar.xz
echo ""
echo "Downloading the packages into the installed /root dir:"
######Directory changing beginning
mkdir sdcardforarch/root
cd sdcardforarch/root
wget -c $linklibnl
wget -c $linklibpcap
wget -c $linkppp
echo ""
echo "Generating install scripts install* to run after login:"
#Back to the names now... adding the -armv7h.pkg.tar.xz though
# ... for #!/bin/bash if I put "" gives me an error because of the !
echo '#!/bin/bash' > install1ppp.sh
cat <<EOF >> install1ppp.sh
echo ""
echo "Installing ppp..."
echo ""
sync
sleep 2
pacman -U --noconfirm --needed $namelibnl-$rpiversion.pkg.tar.xz
pacman -U --noconfirm --needed $namelibpcap-$rpiversion.pkg.tar.xz
pacman -U --noconfirm --needed $nameppp-$rpiversion.pkg.tar.xz
sleep 1
ln -s /etc/ppp/peers/$pppprovider /etc/ppp/peers/provider
sleep 1
cp /etc/ppp/pap-secrets.pacorig /etc/ppp/pap-secrets
cp /etc/ppp/chap-secrets.pacorig /etc/ppp/chap-secrets
sleep 1
sync
sleep 2
echo ""
echo "Stopping systemd messages that need to run systemctl daemon reload:"
echo ""
poff -a
# All of this is needed, including sleeps, to make systemd stop giving this messages
sleep 1
systemctl daemon-reload
sleep 5
sync
sleep 5
systemctl stop systemd-networkd
systemctl disable systemd-networkd
systemctl stop systemd-timesyncd
systemctl disable systemd-timesyncd
systemctl stop ppp@$pppprovider.service
systemctl disable ppp@$pppprovider.service
sleep 2
systemctl daemon-reload
sleep 3
sync
sleep 2
systemctl enable systemd-networkd
systemctl start systemd-networkd
systemctl enable systemd-timesyncd
systemctl start systemd-timesyncd
systemctl enable ppp@$pppprovider.service
systemctl start ppp@$pppprovider.service
sleep 5
sync
sleep 2
systemctl daemon-reload
sleep 3
sync
poff -a
sleep 2
systemctl daemon-reload
sleep 3
sync
sleep 2
systemctl stop ppp@$pppprovider.service
systemctl disable ppp@$pppprovider.service
sleep 2
systemctl daemon-reload
sleep 3
sync
sleep 2
systemctl enable ppp@$pppprovider.service
systemctl start ppp@$pppprovider.service
sleep 5
sync
sleep 2
systemctl daemon-reload
sleep 3
sync
sleep 2
systemctl daemon-reload
sleep 3
echo ""
echo "Completed installing ppp."
echo ""
echo "Internet is available if configuration is correct."
echo ""
echo "But if not paid in time or in a hotel it will be redirected by dns."
echo ""
echo "============================================================"
echo ""
echo "Running systemctl status ppp@$provider.service"
echo ""
systemctl status ppp@$pppprovider.service
sleep 2
systemctl daemon-reload
sleep 3
sync
echo ""
echo "If warning is in the middle then incorrect configuration of user and password."
echo ""
echo "If warning is last then the network cable is disconnected or not well inserted."
echo ""
echo "Repeat this script until no more warnings appear in systemctl status."
sleep 2
sync
EOF
chmod a+x install1ppp.sh
# ... for #!/bin/bash if I put "" gives me an error because of the !
echo '#!/bin/bash' > install2upgrade.sh
cat <<EOF >> install2upgrade.sh
echo ""
echo "Upgrading system... if redirected error 404 will appear..."
echo ""
sync
sleep 2
pacman -Syu --noconfirm
sleep 2
echo ""
echo "Completed upgrading system."
echo ""
echo "Rebooting so that all upgrades run in the memory too."
echo ""
sync
sleep 3
sync
sleep 3
reboot
EOF
chmod a+x install2upgrade.sh
# ... for #!/bin/bash if I put "" gives me an error because of the !
echo '#!/bin/bash' > install3lxde.sh
# Having cat with EOF inside, it is needed to use something else like EOG
cat <<EOG >> install3lxde.sh
echo ""
echo "Installing lxde..."
echo ""
sleep 2
# Making sure package lists are up to date right now
pacman -Syu --noconfirm
sleep 2
# Packages only for the Raspberry Pi or ArchLinuxARM (comment if installing on something else)
pacman -S --noconfirm --needed libbcm2835 xf86-video-fbturbo-git kodi-rbp omxplayer packer
# Console packages - fdisk is in util-linux which is in base-devel
pacman -S --noconfirm --needed base base-devel arch-install-scripts dosfstools libarchive pkgfile iotop gptfdisk parted mkinitcpio upower mc libnewt newt-syrup openssh openssl wiringpi espeak mpg123 flac lame youtube-dl imagemagick git wget libx264 mediainfo
sleep 2
# Sound packages
pacman -S --noconfirm --needed alsa-utils alsa-plugins pulseaudio pulseaudio-alsa paprefs pavucontrol timidity++ timidity-freepats
sleep 2
# Xorg packages
pacman -S --noconfirm --needed unrar unzip unarj p7zip gzip bzip2 xarchiver mesa-libgl ttf-freefont ttf-dejavu xorg-server xorg-xinit libksane xsane-gimp inkscape phonon-qt4-gstreamer phonon-qt5-gstreamer gparted audacious gimp libreoffice-still jre8-openjdk jdk8-openjdk xsane kactivities4
sleep 2
# Lxde packages
pacman -S --noconfirm --needed chromium calligra-krita gpicview lxappearance lxappearance-obconf lxde-common lxde-icon-theme lxdm lxinput lxlauncher lxmenu-data lxmusic lxpanel lxrandr lxsession lxtask lxterminal openbox pcmanfm transmission-gtk leafpad mediainfo-gui
sleep 2
# Game packages
pacman -S --noconfirm --needed openra kobodeluxe klines
sleep 2
sync
sleep 2
echo "exec startlxde" > /root/.xinitrc
echo ""
echo "Configuring boot and /etc/fstab to use UUID for partitions."
echo ""
# The UUID is determined in rpiarchppp as sed can't execute or show variable
sed -i 's/\/dev\/mmcblk0p3/UUID=`blkid -s UUID -o value $rootpart`/g' /boot/cmdline.txt
sed -i 's/rootwait/rootwait initrd=0x01f00000/g' /boot/cmdline.txt
echo "initramfs initrd 0x01f00000" >> /boot/config.txt
genfstab -U / > /etc/fstab
echo ""
echo "Making an initramfs giving the kernel the ability to boot by UUID."
echo ""
echo "This is done automatically for every kernel update."
sed -i 's/ block / /g' /etc/mkinitcpio.conf
sed -i 's/udev/udev block/g' /etc/mkinitcpio.conf
sleep 2
sync
sleep 2
mkinitcpio -k \$(uname -r) -g /boot/initrd
sleep 2
sync
sleep 2
# Kodi leaves a blank screen when exiting, this hack fixes that
mkdir /usr/bin
mkdir /root/.kodi
mkdir /root/.kodi/temp/
echo '#!/bin/bash' > /usr/bin/kodiexitfixroot
echo '' >>  /usr/bin/kodiexitfixroot
echo "if [[ \\\$(tail -1 /root/.kodi/temp/kodi.log | grep \"application stopped...\") ]]; then" >> /usr/bin/kodiexitfixroot
echo '    killall kodi.bin' >> /usr/bin/kodiexitfixroot
echo '    mv /root/.kodi/temp/kodi.log /root/.kodi/temp/kodi.old.log' >> /usr/bin/kodiexitfixroot
echo '    sleep 1 && chvt 2 && sleep 1 && chvt 1' >> /usr/bin/kodiexitfixroot
echo 'fi' >> /usr/bin/kodiexitfixroot
# check depmod is not replaced and repair it again if it has
echo 'if [[ \`cat /usr/bin/depmod |grep "mkinitcpio" |wc -c\` = 0 ]]; then' >> /usr/bin/kodiexitfixroot
# in case replacing is still in progress
echo '    sleep 2' >> /usr/bin/kodiexitfixroot
echo '    rename depmod depmodbin /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo "    echo '#!/bin/bash' > /usr/bin/depmod" >> /usr/bin/kodiexitfixroot
# checking if more parameters or not, when one, for sure it's kernel version, when more, depmodbin alone
echo "    echo 'if [[ \\\`echo \\\$2 |wc -c\\\` != 1 ]]; then' >> /usr/bin/depmod" >> /usr/bin/kodiexitfixroot
echo '    echo "    depmodbin \\\$1 \\\$2 \\\$3 \\\$4 \\\$5 \\\$6 \\\$7 \\\$8 \\\$9" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo '    echo "else" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
# Indicating new version instead of current version
echo '    echo "    depmodbin \\\$1" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo '    echo "    mkinitcpio -k \\\$1 -g /boot/initrd" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo '    echo "fi" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo '    echo "exit 0" >> /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo '    chmod a+x /usr/bin/depmod' >> /usr/bin/kodiexitfixroot
echo 'fi' >> /usr/bin/kodiexitfixroot
echo "exit 0" >> /usr/bin/kodiexitfixroot
chmod a+x /usr/bin/kodiexitfixroot
# Arch uses systemd timers not cron by default
cat <<EOF > /etc/systemd/system/kodiexitfixroot.timer
[Unit]
Description=kodiexitfixroot timer
[Timer]
# Every 30 seconds
OnCalendar=*-*-*  *:*:0/30
Unit=kodiexitfixroot.service
[Install]
WantedBy=timers.target
EOF
cat <<EOF > /etc/systemd/system/kodiexitfixroot.service 
[Unit]
Description=kodiexitfixroot service
[Service]
Type=oneshot
ExecStart=/bin/bash /usr/bin/kodiexitfixroot
EOF
sleep 1
systemctl daemon-reload
sleep 3
systemctl enable kodiexitfixroot.timer
systemctl start kodiexitfixroot.timer
sleep 2
sync
sleep 2
# Hack to allow mc to open videos with omxplayer
cp /usr/lib/mc/ext.d/video.sh /usr/lib/mc/ext.d/video.sh.old
echo '#!/bin/sh' > /usr/lib/mc/ext.d/video.sh
echo "omxplayer \"\\\${MC_EXT_FILENAME}\"" >> /usr/lib/mc/ext.d/video.sh
pkgfile --update
sleep 2
sed -i 's/load-module module-suspend-on-idle/#load-module module-suspend-on-idle/g' /etc/pulse/default.pa
sed -i 's/load-module module-suspend-on-idle/#load-module module-suspend-on-idle/g' /etc/pulse/system.pa
echo "flat-volumes = no" >> /etc/pulse/daemon.conf
echo "high-priority = no" >> /etc/pulse/daemon.conf
echo "nice-level = -1" >> /etc/pulse/daemon.conf
echo "no-cpu-limit = yes" >> /etc/pulse/daemon.conf
sleep 3
systemctl daemon-reload
sleep 5
sync
sleep 3
systemctl --user enable pulseaudio.service
systemctl --user start pulseaudio.service
sleep 3
systemctl daemon-reload
sleep 5
sync
sleep 3
amixer cset numid=3 -- 90%
sed -i 's/chromium %U/chromium --no-sandbox --user-data-dir \/var\/cache\/chromiumdir %U/g' /usr/share/applications/chromium.desktop
ln -s /usr/bin/omxplayer /usr/bin/oi
mkdir /var/cache/chromiumdir
chown 777 /var/cache/chromiumdir
sleep 1
echo ""
echo "Added symbolic links oi and yt to omxplayer and youtube-dl."
echo ""
echo "Added mc option to open all videos with omxplayer."
echo ""
sleep 2
sync
EOG
chmod a+x install3lxde.sh
echo '#!/bin/bash' > install4autologinroot.sh
cat <<EOF >> install4autologinroot.sh
echo ""
echo "Activating autologin root... not recomended but maybe cool..."
echo ""
echo "If you want to keep ssh and have a user, stop this script with (ctrl + c)"
echo ""
sleep 3
echo "5"
echo ""
sleep 2
echo "4"
echo ""
sleep 2
echo "3"
echo ""
sleep 2
echo "2"
echo ""
sleep 2
echo "1"
echo ""
sleep 5
echo "Too late..."
echo ""
sync
sleep 1
systemctl stop sshd.service
systemctl disable sshd.service
echo ""
echo "Wait..."
sleep 1
sync
sleep 1
systemctl daemon-reload
sleep 5
sync
sleep 3
rm /etc/systemd/system/getty.target.wants/getty@tty1.service
cp /lib/systemd/system/getty@.service /etc/systemd/system/getty@tty1.service
sed -i 's/--noclear/--autologin root --noclear/g' /etc/systemd/system/getty@tty1.service
echo ";Alias=getty@tty1.service" >> /etc/systemd/system/getty@tty1.service
ln -s /etc/systemd/system/getty@tty1.service /etc/systemd/system/getty.target.wants/getty@tty1.service
sleep 1
echo ""
echo "Hack for autologing into root console and disabling ssh activated."
echo ""
echo "If you want to build packages, it's hard to be root, you need to:"
echo ""
echo "1) Edit /usr/bin/makepkg"
echo ""
echo "    a) Add 'asroot' in OPT_LONG=()"
echo "    b) Comment and add a sleep 1 inside if (( EUID == 0 ))"
echo ""
echo "2) Use packer to install packages from aur"
echo ""
echo "To avoid tmpfs for /tmp used by packer (large git repositories)"
echo 'alias packer="TMPDIR=/root/tmp/pkgs/ EDITOR=nano /usr/bin/packer"'
echo "Use the alias packer in .bashrc."
echo ""
sleep 2
sync
EOF
chmod a+x install4autologinroot.sh
echo '#!/bin/bash' > install5autostartxroot.sh
cat <<EOF >> install5autostartxroot.sh
echo ""
echo "Activating auto startx at root login..."
echo ""
cp /root/.bash_profile /root/.bash_profile.old
echo "[[ -f ~/.bashrc ]] && . ~/.bashrc" > /root/.bash_profile
echo "[[ -z \\\$DISPLAY && \\\$XDG_VTNR -eq 1 ]] && exec startx" >> /root/.bash_profile
echo 'alias pk="TMPDIR=/root/tmp/pkgs/ EDITOR=nano packer"' >> /root/.bashrc
echo 'alias yt="youtube-dl -f mp4/best"' >> /root/.bashrc
. ~/.bashrc
sleep 1
echo ""
echo "Inserted startx in .bash_profile, original file copied to .bash_profile.old"
echo ""
echo "Use CTRL + ALT + F2 or more to get to a console."
echo ""
echo "Don't run this script again on this install or you lose .bash_profile.old"
echo ""
sleep 2
sync
EOF
chmod a+x install5autostartxroot.sh
echo '#!/bin/bash' > install6localesro-edit.sh
cat <<EOF >> install6localesro-edit.sh
echo ""
echo "Activating locales for Romania..."
echo ""
echo "You can edit this script to activate another..."
echo ""
sed -i 's/#en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/g' /etc/locale.gen
sed -i 's/#ro_RO.UTF-8 UTF-8/ro_RO.UTF-8 UTF-8/g' /etc/locale.gen
sleep 1
locale-gen
sleep 1
localectl set-locale LANG=ro_RO.UTF8
sleep 1
localectl --no-convert set-keymap ro
sleep 1
localectl --no-convert set-x11-keymap ro pc105 ,dvorak grp:alt_shift_toggle
sleep 1
echo "KEYMAP=ro" > /etc/vconsole.conf
sleep 1
rm /etc/localtime
ln -sf /usr/share/zoneinfo/Europe/Bucharest /etc/localtime
sleep 1
echo ""
echo "If you don't like the locale ro, change in this script."
echo ""
echo "View the locale and keymap with list-locales, list-keymaps."
echo ""
echo "Setting timezone is different from locales. Did it also."
echo ""
sync
EOF
chmod a+x install6localesro-edit.sh
cd ../../
######Directory changing ending
echo "Files /root/install* have been written."
echo ""
echo ""
echo "=================================================="
echo ""
echo ""
sync
sleep 2
# Root is on partition 3 not 2, informing cmdline.txt and fstab
mkdir sdcardforarch/etc/
sed -i 's/mmcblk0p2/mmcblk0p3/g' sdcardforarch/boot/cmdline.txt
sed -i 's/mmcblk0p2/mmcblk0p3/g' sdcardforarch/etc/fstab
echo "/dev/mmcblk0p2	none      	swap      	defaults  	0 0" >> sdcardforarch/etc/fstab
# Choosing a mirror
sed -i 's/Server = http:\/\/mirror.archlinuxarm.org\/$arch\/$repo/#Server = http:\/\/mirror.archlinuxarm.org\/$arch\/$repo\n\nServer = http:\/\/nl.mirror.archlinuxarm.org\/$arch\/$repo/g' sdcardforarch/etc/pacman.d/mirrorlist
echo "Configuring  ppp with information from configuration..."
echo ""
mkdir sdcardforarch/etc/ppp
mkdir sdcardforarch/etc/ppp/peers
echo "plugin rp-pppoe.so" > sdcardforarch/etc/ppp/peers/$pppprovider
echo "eth0" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "name \"$pppusername\"" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "usepeerdns" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "persist" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "defaultroute" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "hide-password" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "noauth" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "" >> sdcardforarch/etc/ppp/peers/$pppprovider
echo "File /etc/ppp/peers/$pppprovider is as follows:"
echo ""
cat sdcardforarch/etc/ppp/peers/$pppprovider
echo ""
echo ""
echo "\"$pppusername\"	*	\"$ppppassword\"" > sdcardforarch/etc/ppp/pap-secrets
# For safety I will copy pap-secrets to also chap-secrets
cp sdcardforarch/etc/ppp/pap-secrets sdcardforarch/etc/ppp/chap-secrets
echo "File /etc/ppp/peers/pap-secrets and chap-secrets are as follows:"
echo ""
cat sdcardforarch/etc/ppp/pap-secrets
echo ""
echo ""
mkdir sdcardforarch/etc/modules-load.d
echo "Conf file to load module ppp-generic:"
echo "/etc/modules-load.d/ppp-generic.conf"
echo "ppp-generic" > sdcardforarch/etc/modules-load.d/ppp-generic.conf
echo ""
echo "Conf file to load module snd-bcm2835:"
echo "/etc/modules-load.d/snd-bcm2835.conf"
echo "snd-bcm2835" > sdcardforarch/etc/modules-load.d/snd-bcm2835.conf
echo ""
echo ""
echo "The link to provider will be made by install1.sh"
echo ""
echo "The systemd ppp enable will be made by install1.sh"
echo ""
echo "Conf file to reduce device wear by systemd:"
echo "/etc/systemd/journald.conf.d/disablejournald.conf"
mkdir sdcardforarch/etc/systemd/journald.conf.d
echo "[Journal]" > sdcardforarch/etc/systemd/journald.conf.d/20-disable-journald.conf
echo "Storage=none" >> sdcardforarch/etc/systemd/journald.conf.d/20-disable-journald.conf
echo "Seal=no" >> sdcardforarch/etc/systemd/journald.conf.d/20-disable-journald.conf
echo ""
cat sdcardforarch/etc/systemd/journald.conf.d/20-disable-journald.conf
echo ""
echo ""
echo "Conf file to start network in systemd before pppd:"
echo "Actual file: /etc/systemd/system/ppp@.service.d/ppp.conf"
mkdir sdcardforarch/etc/systemd/system/ppp\@.service.d
echo "[Service]" > sdcardforarch/etc/systemd/system/ppp\@.service.d/ppp.conf
echo "ExecStartPre=/usr/bin/ip link set eth0 up" >> sdcardforarch/etc/systemd/system/ppp\@.service.d/ppp.conf
echo ""
echo "File /etc/systemd/system/ppp\@.service.d/ppp.conf is as follows:"
echo ""
cat sdcardforarch/etc/systemd/system/ppp\@.service.d/ppp.conf
echo ""
echo "Configuring man-db.timer and updatedb.timer to start later."

mkdir sdcardforarch/etc/systemd/system/man-db.timer.d
echo "[Timer]" > sdcardforarch/etc/systemd/system/man-db.timer.d/man-db.timer.conf
echo "OnCalender=" >> sdcardforarch/etc/systemd/system/man-db.timer.d/man-db.timer.conf
echo "OnCalendar=13:15" >> sdcardforarch/etc/systemd/system/man-db.timer.d/man-db.timer.conf
echo "OnBootSec=1200" >> sdcardforarch/etc/systemd/system/man-db.timer.d/man-db.timer.conf
mkdir sdcardforarch/etc/systemd/system/updatedb.timer.d
echo "[Timer]" > sdcardforarch/etc/systemd/system/updatedb.timer.d/updatedb.timer.conf
echo "OnCalender=" >> sdcardforarch/etc/systemd/system/updatedb.timer.d/updatedb.timer.conf
echo "OnCalendar=13:45" >> sdcardforarch/etc/systemd/system/updatedb.timer.d/updatedb.timer.conf
echo "OnBootSec=1800" >> sdcardforarch/etc/systemd/system/updatedb.timer.d/updatedb.timer.conf
echo ""
echo "Conf file to stop kernel messages:"
echo "/etc/sysctl.d/20-quiet-prink.conf"
mkdir sdcardforarch/etc/sysctl.d
echo "kernel.printk = 3 3 3 3" > sdcardforarch/etc/sysctl.d/20-quiet-prink.conf
echo ""
cat sdcardforarch/etc/sysctl.d/20-quiet-prink.conf
echo ""
echo ""
echo "Conf file to improove disk performance:"
echo "/etc/sysctl.d/30-rpi-optimizations.conf"
echo ""
cat <<EOF > sdcardforarch/etc/sysctl.d/30-rpi-optimizations.conf
vm.swappiness = 10
vm.min_free_kbytes = 8192
vm.vfs_cache_pressure = 50
vm.dirty_bytes = 8388608
vm.dirty_background_bytes = 8388608
vm.dirty_writeback_centisecs = 600
vm.dirty_expire_centisecs = 600
# In other words the seven optimizations do this, in their order, each in paranthesis:
#		(keep caches medium and swap low), (keep a free memory of 8 MB), (keep a
#		medium amount of file information in cache), (processes write after reaching
#		8MB in their memory) to a (cache of 8 MB in size), in which (old data is
#		written every 6 seconds) and (data is considered old after 6 seconds).
EOF
echo ""
echo ""
echo "Creating config.txt"; echo ""
cp sdcardforarch/boot/config.txt sdcardforarch/boot/configold.txt
cat <<EOF > sdcardforarch/boot/config.txt
#The other commented options are in config.txt.old
#Rezolution 1280x1024 @ 60 Hz
hdmi_group=2
hdmi_mode=35
#Option hdmi_drive for DVI it's 1, for HDMI with sound (TV, adapter) it's 2
hdmi_drive=2
hdmi_force_edid_audio=1
hdmi_force_hotplug=1
gpu_mem=256
framebuffer_depth=24
# For camera and webm
start_file=start_x.elf
fixup_file=fixup_x.dat
EOF
echo "Conf /etc/X11/xorg.conf.d/50-on-flags.conf for screen always on:"; echo ""
mkdir sdcardforarch/etc/X11
mkdir sdcardforarch/etc/X11/xorg.conf.d
cat <<EOF > sdcardforarch/etc/X11/xorg.conf.d/50-on-flags.conf
Section "ServerFlags"
   Option "BlankTime" "0"
   Option "StandbyTime" "0"
   Option "SuspendTime" "0"
   Option "OffTime" "0"
EndSection
EOF
cp sdcardforarch/boot/config.txt sdcardforarch/boot/confignew.txt
### When config.txt is lost, cp /boot/confignew.txt config.txt
sync
umount $bootpart
umount $rootpart
swapoff $swappart
rm -rf sdcardforarch
rm -rf archcoredbextract
# Keeping Arch image
rm core.db.tar.gz
sync
echo "Completed."
echo ""
end_time=$(date)
echo "Started at:"
echo ""
echo $start_time
echo "Finished at:"
echo ""
echo $end_time
echo ""
echo "Password for root is root. Without the dot."
echo ""
echo "Exiting happy."
echo ""
exit 0
